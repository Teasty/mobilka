//
//  CreationViewController.swift
//  mobilka
//
//  Created by Андрей Лихачев on 03.12.2019.
//  Copyright (c) 2019 Андрей Лихачев. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CreationDisplayLogic: class
{
  func contactAdded()
    func changePhoto(image: UIImage)
}

class CreationViewController: UITableViewController, CreationDisplayLogic
{
  var interactor: CreationBusinessLogic?
  var router: (NSObjectProtocol & CreationRoutingLogic & CreationDataPassing)?

  // MARK: Object lifecycle
  
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
  {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }
  
  required init?(coder aDecoder: NSCoder)
  {
    super.init(coder: aDecoder)
    setup()
  }
  
  // MARK: Setup
  
  private func setup()
  {
    let viewController = self
    let interactor = CreationInteractor()
    let presenter = CreationPresenter()
    let router = CreationRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }
  
  // MARK: Routing
  
  override func prepare(for segue: UIStoryboardSegue, sender: Any?)
  {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }
  
  // MARK: View lifecycle
  
  override func viewDidLoad()
  {
    super.viewDidLoad()

    let toolBar = UIToolbar()
    toolBar.sizeToFit()
    let doneButton = UIBarButtonItem(barButtonSystemItem: .done, target: self, action: #selector(DoneAction))
    let spase = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)
    toolBar.setItems([spase,doneButton], animated: true)
    
    FamilyNameField.inputAccessoryView = toolBar
    NameField.inputAccessoryView = toolBar
    LastNameField.inputAccessoryView = toolBar
    TelephoneField.inputAccessoryView = toolBar
    EmailField.inputAccessoryView = toolBar
    
  }
  
  // MARK: Do something
  
  //@IBOutlet weak var nameTextField: UITextField!
    @IBOutlet weak var AddPhotoButton: UIButton!
    @IBOutlet weak var contactImageView: UIImageView!
    @IBOutlet weak var FamilyNameField: UITextField!
    @IBOutlet weak var NameField: UITextField!
    @IBOutlet weak var LastNameField: UITextField!
    @IBOutlet weak var TelephoneField: UITextField!
    @IBOutlet weak var EmailField: UITextField!
    
    
    
    @IBAction func menuButtonTapped(_ sender: Any) {
        guard let menuVC = storyboard?.instantiateViewController(withIdentifier: "Menu") else {return}
        menuVC.modalPresentationStyle = .overCurrentContext
        menuVC.transitioningDelegate = self
        present(menuVC, animated: true)
    }
    
    
    @IBAction func AddPhotoButtonTapped(_ sender: Any) {
        showImagePickerAlert()
    }
    
    
    @IBAction func AddButtonTapped(_ sender: Any) {
        if !FamilyNameField.text!.isEmpty, !NameField.text!.isEmpty, !LastNameField.text!.isEmpty, !TelephoneField.text!.isEmpty, !EmailField.text!.isEmpty{
            addContact(familyName: FamilyNameField.text!, name: NameField.text!, lastName: LastNameField.text!, phone: TelephoneField.text!, email: EmailField.text!)
        }
        else {
            print("Error.")
        }
    }
    
    
    let transition = SlideTransition()
    
  func addContact(familyName: String, name: String, lastName: String, phone: String, email: String)
  {
    let request = Creation.Models.Contact(familyName: familyName, name: name, lastName: lastName, phone: phone, email: email)
    interactor?.doSomething(request: request)
  }
  
  func contactAdded()
  {
    AddPhotoButton.isHidden = false
    contactImageView.image = nil
    contactImageView.backgroundColor = .opaqueSeparator
    FamilyNameField.text = ""
    NameField.text = ""
    LastNameField.text = ""
    TelephoneField.text = ""
    EmailField.text = ""
  }
    
    
    func changePhoto(image: UIImage){
        contactImageView.image = image
        contactImageView.backgroundColor = .clear
        AddPhotoButton.isHidden = true
    }
    
    
    @objc func DoneAction(){
        self.view.endEditing(true)
    }
    
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.view.endEditing(true)
    }
    
}



extension CreationViewController: UIViewControllerTransitioningDelegate {
    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        transition.isPresenting = true
        return transition
    }
    
    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        transition.isPresenting = false
        return transition
    }
}



// MARK: ImagePicker (Для Кости)


extension CreationViewController: UIImagePickerControllerDelegate,UINavigationControllerDelegate{
    
    // Вывод алерта с выбором источника фото
    func showImagePickerAlert(){
//        Из галереи
        let photoLibraryAction = UIAlertAction(title: "Выбрать из галереи", style: .default) {(action) in
            self.showImagePickerController(sourceType: .photoLibrary)
        }
//        сфоткать
        let cameraAction = UIAlertAction(title: "Сделать снимок", style: .default) {(action) in
            self.showImagePickerController(sourceType: .camera)
        }
//        Отмена
        let cancelAction = UIAlertAction(title: "Отмена", style: .cancel, handler: nil)
        
        AlertService.showAlert(style: .actionSheet, title: "Выберите фотографию", message: nil, actions: [photoLibraryAction, cameraAction, cancelAction], completion: nil)
        
    }
    
//    запускаем пиккер с нужным типом (sourseType)
    func showImagePickerController(sourceType: UIImagePickerController.SourceType){
        let imagePickerController = UIImagePickerController()
        imagePickerController.delegate = self
        imagePickerController.sourceType = sourceType
        present(imagePickerController, animated: true, completion: nil)
    }
//    Действия после выбора изображения
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        
        if let image = info[UIImagePickerController.InfoKey.originalImage] as? UIImage {
            self.changePhoto(image: image)
        }
            
            
        dismiss(animated: true, completion: nil)
    }
}


//  Класс необходимый для кастомного алерта
class AlertService {
    
    static func showAlert(style: UIAlertController.Style, title: String?, message: String?, actions: [UIAlertAction] = [UIAlertAction(title: "Ok", style: .cancel, handler: nil)], completion: (() -> Swift.Void)? = nil) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: style)
        for action in actions {
            alert.addAction(action)
        }
        if let topVC = UIApplication.getTopMostViewController() {
            alert.popoverPresentationController?.sourceView = topVC.view
            alert.popoverPresentationController?.sourceRect = CGRect(x: topVC.view.bounds.midX, y: topVC.view.bounds.midY, width: 0, height: 0)
            alert.popoverPresentationController?.permittedArrowDirections = []
            topVC.present(alert, animated: true, completion: completion)
        }
    }
}


//  Расширения класса кторый выберает верхний в иерархии контроллер
extension UIApplication {
    class func getTopMostViewController(base: UIViewController? = UIApplication.shared.keyWindow?.rootViewController) -> UIViewController? {
        if let nav = base as? UINavigationController {
            return getTopMostViewController(base: nav.visibleViewController)
        }
        if let tab = base as? UITabBarController {
            if let selected = tab.selectedViewController {
                return getTopMostViewController(base: selected)
            }
        }
        if let presented = base?.presentedViewController {
            return getTopMostViewController(base: presented)
        }
        return base
    }
}
